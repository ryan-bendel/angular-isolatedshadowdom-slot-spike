{"version":3,"file":"_dom_renderer-chunk.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/src/dom/events/dom_events.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/src/dom/events/event_manager.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/src/dom/shared_styles_host.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/src/dom/isolated_style_scope.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/src/dom/dom_renderer.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, type ListenerOptions} from '@angular/core';\nimport {EventManagerPlugin} from './event_manager_plugin';\n\n@Injectable()\nexport class DomEventsPlugin extends EventManagerPlugin {\n  constructor(@Inject(DOCUMENT) doc: any) {\n    super(doc);\n  }\n\n  // This plugin should come last in the list of plugins, because it accepts all\n  // events.\n  override supports(eventName: string): boolean {\n    return true;\n  }\n\n  override addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    element.addEventListener(eventName, handler as EventListener, options);\n    return () => this.removeEventListener(element, eventName, handler as EventListener, options);\n  }\n\n  removeEventListener(\n    target: any,\n    eventName: string,\n    callback: Function,\n    options?: ListenerOptions,\n  ): void {\n    return target.removeEventListener(eventName, callback as EventListener, options);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  ɵRuntimeError as RuntimeError,\n  type ListenerOptions,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\nimport type {EventManagerPlugin} from './event_manager_plugin';\n\nimport {DomEventsPlugin} from './dom_events';\n\n/**\n * The injection token for plugins of the `EventManager` service.\n *\n * @see [Extend event handling](guide/templates/event-listeners#extend-event-handling)\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS = new InjectionToken<EventManagerPlugin[]>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'EventManagerPlugins' : '',\n);\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(\n    @Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[],\n    private _zone: NgZone,\n  ) {\n    plugins.forEach((plugin) => {\n      plugin.manager = this;\n    });\n\n    const otherPlugins = plugins.filter((p) => !(p instanceof DomEventsPlugin));\n    this._plugins = otherPlugins.slice().reverse();\n\n    // DomEventsPlugin.supports() always returns true, it should always be the last plugin.\n    const domEventPlugin = plugins.find((p) => p instanceof DomEventsPlugin);\n    if (domEventPlugin) {\n      this._plugins.push(domEventPlugin);\n    }\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @param options Options that configure how the event listener is bound.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(\n    element: HTMLElement,\n    eventName: string,\n    handler: Function,\n    options?: ListenerOptions,\n  ): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler, options);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone {\n    return this._zone;\n  }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    let plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    plugin = plugins.find((plugin) => plugin.supports(eventName));\n    if (!plugin) {\n      throw new RuntimeError(\n        RuntimeErrorCode.NO_PLUGIN_FOR_EVENT,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `No event manager plugin found for event ${eventName}`,\n      );\n    }\n\n    this._eventNameToPlugin.set(eventName, plugin);\n    return plugin;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  APP_ID,\n  CSP_NONCE,\n  Inject,\n  Injectable,\n  OnDestroy,\n  Optional,\n  PLATFORM_ID,\n} from '@angular/core';\n\n/** The style elements attribute name used to set value of `APP_ID` token. */\nconst APP_ID_ATTRIBUTE_NAME = 'ng-app-id';\n\n/**\n * A record of usage for a specific style including all elements added to the DOM\n * that contain a given style.\n */\ninterface UsageRecord<T> {\n  elements: T[];\n  usage: number;\n}\n\n/**\n * Removes all provided elements from the document.\n * @param elements An array of HTML Elements.\n */\nfunction removeElements(elements: Iterable<HTMLElement>): void {\n  for (const element of elements) {\n    element.remove();\n  }\n}\n\n/**\n * Creates a `style` element with the provided inline style content.\n * @param style A string of the inline style content.\n * @param doc A DOM Document to use to create the element.\n * @returns An HTMLStyleElement instance.\n */\nfunction createStyleElement(style: string, doc: Document): HTMLStyleElement {\n  const styleElement = doc.createElement('style');\n  styleElement.textContent = style;\n\n  return styleElement;\n}\n\n/**\n * Searches a DOM document's head element for style elements with a matching application\n * identifier attribute (`ng-app-id`) to the provide identifier and adds usage records for each.\n * @param doc An HTML DOM document instance.\n * @param appId A string containing an Angular application identifer.\n * @param inline A Map object for tracking inline (defined via `styles` in component decorator) style usage.\n * @param external A Map object for tracking external (defined via `styleUrls` in component decorator) style usage.\n */\nfunction addServerStyles(\n  doc: Document,\n  appId: string,\n  inline: Map<string, UsageRecord<HTMLStyleElement>>,\n  external: Map<string, UsageRecord<HTMLLinkElement>>,\n): void {\n  const elements = doc.head?.querySelectorAll<HTMLStyleElement | HTMLLinkElement>(\n    `style[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"],link[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"]`,\n  );\n\n  if (elements) {\n    for (const styleElement of elements) {\n      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);\n      if (styleElement instanceof HTMLLinkElement) {\n        // Only use filename from href\n        // The href is build time generated with a unique value to prevent duplicates.\n        external.set(styleElement.href.slice(styleElement.href.lastIndexOf('/') + 1), {\n          usage: 0,\n          elements: [styleElement],\n        });\n      } else if (styleElement.textContent) {\n        inline.set(styleElement.textContent, {usage: 0, elements: [styleElement]});\n      }\n    }\n  }\n}\n\n/**\n * Creates a `link` element for the provided external style URL.\n * @param url A string of the URL for the stylesheet.\n * @param doc A DOM Document to use to create the element.\n * @returns An HTMLLinkElement instance.\n */\nexport function createLinkElement(url: string, doc: Document): HTMLLinkElement {\n  const linkElement = doc.createElement('link');\n  linkElement.setAttribute('rel', 'stylesheet');\n  linkElement.setAttribute('href', url);\n\n  return linkElement;\n}\n\n@Injectable()\nexport class SharedStylesHost implements OnDestroy {\n  /**\n   * Provides usage information for active inline style content and associated HTML <style> elements per host.\n   * Embedded styles typically originate from the `styles` metadata of a rendered component.\n   */\n  private readonly inline = new Map<\n    ShadowRoot | HTMLHeadElement,\n    Map<string, UsageRecord<HTMLStyleElement>>\n  >();\n\n  /**\n   * Provides usage information for active external style URLs and the associated HTML <link> elements per host.\n   * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.\n   */\n  private readonly external = new Map<\n    ShadowRoot | HTMLHeadElement,\n    Map<string, UsageRecord<HTMLLinkElement>>\n  >();\n\n  /**\n   * Set of host DOM nodes that will have styles attached.\n   */\n  private readonly standardShadowHosts = new Set<Node>();\n  private readonly isolatedShadowRoots: ShadowRoot[] = [];\n\n  constructor(\n    @Inject(DOCUMENT) private readonly doc: Document,\n    @Inject(APP_ID) private readonly appId: string,\n    @Inject(CSP_NONCE) @Optional() private readonly nonce?: string | null,\n    // Cannot remove it due to backward compatibility\n    // (it seems some TGP targets might be calling this constructor directly).\n    @Inject(PLATFORM_ID) platformId: object = {},\n  ) {\n    // Initialize maps for document head\n    const inlineMap = new Map();\n    const externalMap = new Map();\n    this.inline.set(doc.head, inlineMap);\n    this.external.set(doc.head, externalMap);\n\n    addServerStyles(doc, appId, inlineMap, externalMap);\n    this.standardShadowHosts.add(doc.head);\n  }\n\n  /**\n   * Adds embedded styles to the DOM via HTML `style` elements.\n   *\n   * Modified to support IsolatedShadowDom by accepting a specific target shadow root.\n   * This ensures styles are only added where they're actually needed rather than broadcasting\n   * to all active shadow roots.\n   *\n   * @param styles An array of style content strings.\n   * @param urls An optional array of external stylesheet URL strings.\n   * @param shadowRoot Optional shadow root to add styles to. If provided, styles go only to this shadow root.\n   *                   If not provided, styles go to document head and all standard shadow DOM hosts.\n   */\n  addStyles(styles: string[], urls?: string[], shadowRoot?: ShadowRoot): void {\n    for (const style of styles) {\n      this.addUsage(style, this.inline, createStyleElement, shadowRoot);\n    }\n    urls?.forEach((url) => this.addUsage(url, this.external, createLinkElement, shadowRoot));\n  }\n\n  /**\n   * Removes embedded styles from the DOM that were added as HTML `style` elements.\n   * @param styles An array of style content strings.\n   * @param urls An optional array of external stylesheet URL strings to remove.\n   * @param shadowRoot Optional shadow root to remove styles from (for IsolatedShadowDom).\n   */\n  removeStyles(styles: string[], urls?: string[], shadowRoot?: ShadowRoot): void {\n    for (const value of styles) {\n      this.removeUsage(value, this.inline, shadowRoot);\n    }\n\n    urls?.forEach((value) => this.removeUsage(value, this.external, shadowRoot));\n  }\n\n  /**\n   * Handle timing issues with projected components. When adding styles to an\n   * IsolatedShadowDom shadow root, we check if the same styles were previously added to doc.head\n   * due to timing issues (renderer creation before DOM attachment). If so, we clean up the\n   * incorrect doc.head styles to prevent duplication.\n   */\n  protected addUsage<T extends HTMLElement>(\n    value: string,\n    usagesMap: Map<ShadowRoot | HTMLHeadElement, Map<string, UsageRecord<T>>>,\n    creator: (value: string, doc: Document) => T,\n    targetShadowRoot?: ShadowRoot,\n  ): void {\n    if (targetShadowRoot) {\n      // Styles are targeted to a specific shadow root\n      this.addUsageToTarget(value, usagesMap, creator, targetShadowRoot);\n    } else {\n      // Global mode: add to document head and all standard shadow DOM hosts\n      this.addUsageToTarget(value, usagesMap, creator, this.doc.head, true);\n    }\n  }\n\n  /**\n   * Helper method that handles adding styles to a specific target container\n   * while managing usage tracking and deduplication.\n   *\n   * @param shouldAddToHosts When true and styleRoot is document head, creates elements for all hosts\n   *                         (preserves original behavior for standard ShadowDom encapsulation)\n   */\n  private addUsageToTarget<T extends HTMLElement>(\n    value: string,\n    usagesMap: Map<ShadowRoot | HTMLHeadElement, Map<string, UsageRecord<T>>>,\n    creator: (value: string, doc: Document) => T,\n    styleRoot: ShadowRoot | HTMLHeadElement,\n    shouldAddToHosts = false,\n  ): void {\n    let usages = usagesMap.get(styleRoot);\n    if (!usages) {\n      usages = new Map();\n      usagesMap.set(styleRoot, usages);\n    }\n\n    const record = usages.get(value);\n    if (record) {\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && record.usage === 0) {\n        record.elements.forEach((element) => element.setAttribute('ng-style-reused', ''));\n      }\n      record.usage++;\n      return;\n    }\n\n    // Create new usage record\n    const elements: T[] = [];\n    // HISTORICAL CONTEXT: This behavior exists for backwards compatibility with standard ShadowDom.\n    //\n    // When Angular originally implemented ShadowDom encapsulation, it had a design flaw:\n    // styles from emulated/none-encapsulated components were added to document.head AND\n    // also broadcast to ALL existing shadow roots. This meant that emulated component styles\n    // would \"leak\" into unrelated shadow DOM components, breaking true encapsulation.\n    //\n    // While this is technically incorrect behavior (shadow DOM should be isolated),\n    // changing it would break existing applications that accidentally depend on this\n    // style leakage. Therefore, we preserve this flawed behavior for standard ShadowDom.\n    //\n    if (shouldAddToHosts && styleRoot === this.doc.head && this.standardShadowHosts.size > 0) {\n      // For document head, create elements for all hosts (original behavior for standard ShadowDom)\n      for (const host of this.standardShadowHosts) {\n        elements.push(this.addElement(host, creator(value, this.doc)));\n      }\n    } else {\n      // For shadow roots or when not adding to hosts, create element for the specific target\n      elements.push(this.addElement(styleRoot, creator(value, this.doc)));\n    }\n\n    usages.set(value, {usage: 1, elements});\n  }\n\n  /**\n   * Removal logic to match the new precise targeting approach.\n   * Previously removed styles from all active shadow roots, now removes only from\n   * the specific target. This prevents accidental removal of styles from unrelated\n   * IsolatedShadowDom components.\n   */\n  protected removeUsage<T extends HTMLElement>(\n    value: string,\n    usagesMap: Map<ShadowRoot | HTMLHeadElement, Map<string, UsageRecord<T>>>,\n    targetShadowRoot?: ShadowRoot,\n  ): void {\n    if (targetShadowRoot) {\n      // Remove from specific shadow root\n      this.removeUsageFromTarget(value, usagesMap, targetShadowRoot);\n    } else {\n      // Remove from document head only\n      this.removeUsageFromTarget(value, usagesMap, this.doc.head);\n    }\n  }\n  /**\n   * Helper method for removing styles from a specific target container.\n   */\n  private removeUsageFromTarget<T extends HTMLElement>(\n    value: string,\n    usagesMap: Map<ShadowRoot | HTMLHeadElement, Map<string, UsageRecord<T>>>,\n    styleRoot: ShadowRoot | HTMLHeadElement,\n  ): void {\n    const usages = usagesMap.get(styleRoot);\n    if (!usages) return;\n\n    const record = usages.get(value);\n    if (record) {\n      record.usage--;\n      if (record.usage <= 0) {\n        removeElements(record.elements);\n        usages.delete(value);\n      }\n    }\n  }\n\n  ngOnDestroy(): void {\n    for (const usages of [...this.inline.values(), ...this.external.values()]) {\n      for (const [, {elements}] of usages) {\n        removeElements(elements);\n      }\n    }\n    this.standardShadowHosts.clear();\n  }\n\n  /**\n   * Adds a host node to the set of style hosts and adds all existing style usage to\n   * the newly added host node.\n   *\n   * This is currently only used for Shadow DOM encapsulation mode.\n   */\n  addHost(hostNode: Node): void {\n    this.standardShadowHosts.add(hostNode);\n\n    // Add existing styles to new host (original behavior, adapted for nested structure)\n    const headInline = this.inline.get(this.doc.head);\n    const headExternal = this.external.get(this.doc.head);\n\n    if (headInline) {\n      for (const [style, {elements}] of headInline) {\n        elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));\n      }\n    }\n\n    if (headExternal) {\n      for (const [url, {elements}] of headExternal) {\n        elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));\n      }\n    }\n  }\n\n  removeHost(hostNode: Node): void {\n    this.standardShadowHosts.delete(hostNode);\n\n    // Clean up usage maps for removed host\n    const hostKey = hostNode as ShadowRoot | HTMLHeadElement;\n    const inlineUsages = this.inline.get(hostKey);\n    const externalUsages = this.external.get(hostKey);\n\n    if (inlineUsages) {\n      for (const {elements} of inlineUsages.values()) {\n        removeElements(elements);\n      }\n      this.inline.delete(hostKey);\n    }\n\n    if (externalUsages) {\n      for (const {elements} of externalUsages.values()) {\n        removeElements(elements);\n      }\n      this.external.delete(hostKey);\n    }\n  }\n\n  private addElement<T extends HTMLElement>(host: Node, element: T): T {\n    if (this.nonce) {\n      element.setAttribute('nonce', this.nonce);\n    }\n\n    // Add application identifier when on the server to support client-side reuse\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);\n    }\n    host.appendChild(element);\n    return element;\n  }\n\n  addShadowRoot(shadowRoot: ShadowRoot): void {\n    // Throw error if using isolated shadow roots in SSR mode\n    if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n      throw new Error(\n        'IsolatedShadowRoot is not supported in SSR mode until declarative shadow DOM is supported.',\n      );\n    }\n\n    // Check if ShadowRoot is supported in this environment\n    if (typeof ShadowRoot === 'undefined') {\n      throw new Error('ShadowRoot is not supported in this environment.');\n    }\n\n    if (\n      typeof ngDevMode !== 'undefined' &&\n      ngDevMode &&\n      this.isolatedShadowRoots.includes(shadowRoot)\n    ) {\n      throw new Error('Shadow root is already registered.');\n    }\n\n    this.isolatedShadowRoots.push(shadowRoot);\n  }\n\n  removeShadowRoot(shadowRoot: ShadowRoot): void {\n    const index = this.isolatedShadowRoots.indexOf(shadowRoot);\n\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && ngDevMode && index === -1) {\n      throw new Error('Attempted to remove shadow root that was not previously added.');\n    }\n\n    this.isolatedShadowRoots.splice(index, 1);\n\n    // Clean up usage maps for removed shadow root\n    const inlineUsages = this.inline.get(shadowRoot);\n    const externalUsages = this.external.get(shadowRoot);\n\n    if (inlineUsages) {\n      for (const {elements} of inlineUsages.values()) {\n        removeElements(elements);\n      }\n      this.inline.delete(shadowRoot);\n    }\n\n    if (externalUsages) {\n      for (const {elements} of externalUsages.values()) {\n        removeElements(elements);\n      }\n      this.external.delete(shadowRoot);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  Injectable,\n  ɵgetLContext as getLContext,\n  ɵunwrapRNode as unwrapRNode,\n  ɵHOST as HOST,\n  ɵPARENT as PARENT,\n} from '@angular/core';\n\n/**\n * Service that tracks active shadow DOM contexts and determines where styles should be applied\n * for IsolatedShadowDom encapsulation.\n */\n@Injectable({providedIn: 'root'})\nexport class IsolatedStyleScopeService {\n  // Track isolated shadow roots with their host elements\n  private isolatedShadowRoots = new Map<ShadowRoot, Element>();\n  // Track standard shadow roots with their host elements\n  private standardShadowRoots = new Map<ShadowRoot, Element>();\n\n  registerIsolatedShadowRoot(shadowRoot: ShadowRoot): void {\n    this.isolatedShadowRoots.set(shadowRoot, shadowRoot.host);\n  }\n\n  registerStandardShadowRoot(shadowRoot: ShadowRoot): void {\n    this.standardShadowRoots.set(shadowRoot, shadowRoot.host);\n  }\n\n  deregisterIsolatedShadowRoot(shadowRoot: ShadowRoot): void {\n    this.isolatedShadowRoots.delete(shadowRoot);\n  }\n\n  deregisterStandardShadowRoot(shadowRoot: ShadowRoot): void {\n    this.standardShadowRoots.delete(shadowRoot);\n  }\n\n  /**\n   * Determines where styles should be applied by checking the shadow DOM context.\n   * Uses Angular's LView hierarchy combined with DOM checks for robustness.\n   */\n  determineStyleTargets(element: HTMLElement): ShadowRoot[] {\n    if (typeof ShadowRoot === 'undefined') {\n      return [];\n    }\n\n    // Check if element is already inside a shadow root\n    const elementRoot = element.getRootNode();\n    if (elementRoot instanceof ShadowRoot && this.isRegisteredShadowRoot(elementRoot)) {\n      return this.getShadowRootsForContext(elementRoot);\n    }\n\n    // Try Angular's LView hierarchy with DOM ancestor checking\n    try {\n      const result = this.findShadowRootViaLView(element);\n      if (result) {\n        return result;\n      }\n    } catch (e) {\n      // LView not available, return empty to use broadcast behavior\n    }\n\n    return [];\n  }\n\n  /**\n   * Finds shadow root hosts using Angular's LView hierarchy.\n   *\n   * Note: With IsolatedShadowDom, ng-content projection is disabled and native <slot>\n   * elements are used instead. This means projected content stays in the light DOM,\n   * so we only need to check the LView hierarchy - no DOM walking required.\n   */\n  private findShadowRootViaLView(element: HTMLElement): ShadowRoot[] | null {\n    const context = getLContext(element);\n    if (!context || !context.lView) {\n      return null;\n    }\n\n    // Traverse LView hierarchy to find component hosts\n    let lView = context.lView;\n    const visited = new Set<any>();\n\n    while (lView && !visited.has(lView)) {\n      visited.add(lView);\n\n      const hostRNode = lView[HOST];\n      if (hostRNode) {\n        const hostElement = unwrapRNode(hostRNode);\n        if (hostElement instanceof Element) {\n          const shadowRoots = this.checkIfShadowRootHost(hostElement);\n          if (shadowRoots) {\n            return shadowRoots;\n          }\n        }\n      }\n\n      const parentLView = lView[PARENT];\n      if (parentLView && Array.isArray(parentLView) && parentLView[HOST] !== undefined) {\n        lView = parentLView as any;\n      } else {\n        break;\n      }\n    }\n\n\n    return null;\n  }\n\n  /**\n   * Checks if the given element is a shadow root host and returns appropriate shadow roots.\n   */\n  private checkIfShadowRootHost(element: Element): ShadowRoot[] | null {\n    for (const [shadowRoot, host] of [...this.isolatedShadowRoots, ...this.standardShadowRoots]) {\n      if (host === element) {\n        return this.getShadowRootsForContext(shadowRoot);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns the appropriate shadow roots based on whether it's isolated or standard.\n   */\n  private getShadowRootsForContext(shadowRoot: ShadowRoot): ShadowRoot[] {\n    if (this.isIsolatedShadowRoot(shadowRoot)) {\n      return [shadowRoot];\n    } else {\n      return Array.from(this.standardShadowRoots.keys());\n    }\n  }\n\n  private isRegisteredShadowRoot(shadowRoot: ShadowRoot): boolean {\n    return this.isolatedShadowRoots.has(shadowRoot) || this.standardShadowRoots.has(shadowRoot);\n  }\n\n  /**\n   * Check if a shadow root is registered as an isolated shadow root\n   */\n  isIsolatedShadowRoot(shadowRoot: ShadowRoot): boolean {\n    return this.isolatedShadowRoots.has(shadowRoot);\n  }\n\n  /**\n   * Check if a shadow root is registered as a standard shadow root\n   */\n  isStandardShadowRoot(shadowRoot: ShadowRoot): boolean {\n    return this.standardShadowRoots.has(shadowRoot);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\nimport {\n  APP_ID,\n  CSP_NONCE,\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgZone,\n  OnDestroy,\n  PLATFORM_ID,\n  Renderer2,\n  RendererFactory2,\n  RendererStyleFlags2,\n  RendererType2,\n  ViewEncapsulation,\n  ɵRuntimeError as RuntimeError,\n  type ListenerOptions,\n  ɵTracingService as TracingService,\n  ɵTracingSnapshot as TracingSnapshot,\n  Optional,\n  ɵallLeavingAnimations as allLeavingAnimations,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {EventManager} from './events/event_manager';\nimport {createLinkElement, SharedStylesHost} from './shared_styles_host';\nimport {IsolatedStyleScopeService} from './isolated_style_scope';\n\nexport const NAMESPACE_URIS: {[ns: string]: string} = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/',\n  'math': 'http://www.w3.org/1998/Math/MathML',\n};\n\nconst COMPONENT_REGEX = /%COMP%/g;\nconst SOURCEMAP_URL_REGEXP = /\\/\\*#\\s*sourceMappingURL=(.+?)\\s*\\*\\//;\nconst PROTOCOL_REGEXP = /^https?:/;\n\nexport const COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\n/**\n * The default value for the `REMOVE_STYLES_ON_COMPONENT_DESTROY` DI token.\n */\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;\n\n/**\n * A DI token that indicates whether styles\n * of destroyed components should be removed from DOM.\n *\n * By default, the value is set to `true`.\n * @publicApi\n */\nexport const REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken<boolean>(\n  ngDevMode ? 'RemoveStylesOnCompDestroy' : '',\n  {\n    providedIn: 'root',\n    factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT,\n  },\n);\n\nexport function shimContentAttribute(componentShortId: string): string {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimHostAttribute(componentShortId: string): string {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimStylesContent(compId: string, styles: string[]): string[] {\n  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));\n}\n\n/**\n * Prepends a baseHref to the `sourceMappingURL` within the provided CSS content.\n * If the `sourceMappingURL` contains an inline (encoded) map, the function skips processing.\n *\n * @note For inline stylesheets, the `sourceMappingURL` is relative to the page's origin\n * and not the provided baseHref. This function is needed as when accessing the page with a URL\n * containing two or more segments.\n * For example, if the baseHref is set to `/`, and you visit a URL like `http://localhost/foo/bar`,\n * the map would be requested from `http://localhost/foo/bar/comp.css.map` instead of what you'd expect,\n * which is `http://localhost/comp.css.map`. This behavior is corrected by modifying the `sourceMappingURL`\n * to ensure external source maps are loaded relative to the baseHref.\n *\n\n * @param baseHref - The base URL to prepend to the `sourceMappingURL`.\n * @param styles - An array of CSS content strings, each potentially containing a `sourceMappingURL`.\n * @returns The updated array of CSS content strings with modified `sourceMappingURL` values,\n * or the original content if no modification is needed.\n */\nexport function addBaseHrefToCssSourceMap(baseHref: string, styles: string[]): string[] {\n  if (!baseHref) {\n    return styles;\n  }\n\n  const absoluteBaseHrefUrl = new URL(baseHref, 'http://localhost');\n\n  return styles.map((cssContent) => {\n    if (!cssContent.includes('sourceMappingURL=')) {\n      return cssContent;\n    }\n\n    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {\n      if (\n        sourceMapUrl[0] === '/' ||\n        sourceMapUrl.startsWith('data:') ||\n        PROTOCOL_REGEXP.test(sourceMapUrl)\n      ) {\n        return `/*# sourceMappingURL=${sourceMapUrl} */`;\n      }\n\n      const {pathname: resolvedSourceMapUrl} = new URL(sourceMapUrl, absoluteBaseHrefUrl);\n\n      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;\n    });\n  });\n}\n\n@Injectable()\nexport class DomRendererFactory2 implements RendererFactory2, OnDestroy {\n  private readonly rendererByCompId = new Map<\n    string,\n    EmulatedEncapsulationDomRenderer2 | NoneEncapsulationDomRenderer\n  >();\n  private readonly defaultRenderer: Renderer2;\n  private readonly platformIsServer: boolean;\n\n  constructor(\n    private readonly eventManager: EventManager,\n    private readonly sharedStylesHost: SharedStylesHost,\n    @Inject(APP_ID) private readonly appId: string,\n    @Inject(REMOVE_STYLES_ON_COMPONENT_DESTROY) private removeStylesOnCompDestroy: boolean,\n    @Inject(DOCUMENT) private readonly doc: Document,\n    @Inject(PLATFORM_ID) readonly platformId: Object,\n    readonly ngZone: NgZone,\n    @Inject(CSP_NONCE) private readonly nonce: string | null = null,\n    @Inject(TracingService)\n    @Optional()\n    private readonly tracingService: TracingService<TracingSnapshot> | null = null,\n    private readonly styleScopeService: IsolatedStyleScopeService,\n  ) {\n    this.platformIsServer = typeof ngServerMode !== 'undefined' && ngServerMode;\n    this.defaultRenderer = new DefaultDomRenderer2(\n      eventManager,\n      doc,\n      ngZone,\n      this.platformIsServer,\n      this.tracingService,\n    );\n  }\n\n  createRenderer(element: any, type: RendererType2 | null): Renderer2 {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n\n    if (\n      typeof ngServerMode !== 'undefined' &&\n      ngServerMode &&\n      (type.encapsulation === ViewEncapsulation.ShadowDom ||\n        type.encapsulation === ViewEncapsulation.IsolatedShadowDom)\n    ) {\n      // Domino does not support shadow DOM.\n      type = {...type, encapsulation: ViewEncapsulation.Emulated};\n    }\n\n    const renderer = this.getOrCreateRenderer(element, type);\n    // Renderers have different logic due to different encapsulation behaviours.\n    // Ex: for emulated, an attribute is added to the element.\n    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n      renderer.applyToHost(element);\n    } else if (renderer instanceof NoneEncapsulationDomRenderer) {\n      renderer.applyStyles(element);\n    }\n\n    return renderer;\n  }\n\n  private getOrCreateRenderer(element: HTMLElement, type: RendererType2): Renderer2 {\n    const rendererByCompId = this.rendererByCompId;\n    let renderer = rendererByCompId.get(type.id);\n\n    if (!renderer) {\n      const doc = this.doc;\n      const ngZone = this.ngZone;\n      const eventManager = this.eventManager;\n      const sharedStylesHost = this.sharedStylesHost;\n      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;\n      const platformIsServer = this.platformIsServer;\n      const tracingService = this.tracingService;\n\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          renderer = new EmulatedEncapsulationDomRenderer2(\n            eventManager,\n            sharedStylesHost,\n            type,\n            this.appId,\n            removeStylesOnCompDestroy,\n            doc,\n            ngZone,\n            platformIsServer,\n            tracingService,\n            this.styleScopeService,\n          );\n          break;\n        case ViewEncapsulation.ShadowDom:\n        case ViewEncapsulation.IsolatedShadowDom:\n          return new ShadowDomRenderer(\n            eventManager,\n            element,\n            type,\n            doc,\n            ngZone,\n            this.nonce,\n            platformIsServer,\n            tracingService,\n            sharedStylesHost,\n            this.styleScopeService,\n          );\n        default:\n          renderer = new NoneEncapsulationDomRenderer(\n            eventManager,\n            sharedStylesHost,\n            type,\n            removeStylesOnCompDestroy,\n            doc,\n            ngZone,\n            platformIsServer,\n            tracingService,\n            this.styleScopeService,\n            undefined,\n          );\n          break;\n      }\n\n      rendererByCompId.set(type.id, renderer);\n    }\n\n    return renderer;\n  }\n\n  ngOnDestroy() {\n    this.rendererByCompId.clear();\n  }\n\n  /**\n   * Used during HMR to clear any cached data about a component.\n   * @param componentId ID of the component that is being replaced.\n   */\n  protected componentReplaced(componentId: string) {\n    this.rendererByCompId.delete(componentId);\n  }\n}\n\nclass DefaultDomRenderer2 implements Renderer2 {\n  data: {[key: string]: any} = Object.create(null);\n\n  /**\n   * By default this renderer throws when encountering synthetic properties\n   * This can be disabled for example by the AsyncAnimationRendererFactory\n   */\n  throwOnSyntheticProps = true;\n\n  constructor(\n    private readonly eventManager: EventManager,\n    private readonly doc: Document,\n    protected readonly ngZone: NgZone,\n    protected readonly platformIsServer: boolean,\n    private readonly tracingService: TracingService<TracingSnapshot> | null,\n  ) {}\n\n  destroy(): void {}\n\n  destroyNode = null;\n\n  createElement(name: string, namespace?: string): any {\n    if (namespace) {\n      // TODO: `|| namespace` was added in\n      // https://github.com/angular/angular/commit/2b9cc8503d48173492c29f5a271b61126104fbdb to\n      // support how Ivy passed around the namespace URI rather than short name at the time. It did\n      // not, however extend the support to other parts of the system (setAttribute, setAttribute,\n      // and the ServerRenderer). We should decide what exactly the semantics for dealing with\n      // namespaces should be and make it consistent.\n      // Related issues:\n      // https://github.com/angular/angular/issues/44028\n      // https://github.com/angular/angular/issues/44883\n      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n\n    return this.doc.createElement(name);\n  }\n\n  createComment(value: string): any {\n    return this.doc.createComment(value);\n  }\n\n  createText(value: string): any {\n    return this.doc.createTextNode(value);\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(newChild);\n  }\n\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      const targetParent = isTemplateNode(parent) ? parent.content : parent;\n      targetParent.insertBefore(newChild, refChild);\n    }\n  }\n\n  removeChild(_parent: any, oldChild: any): void {\n    // child was removed\n    oldChild.remove();\n  }\n\n  selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any {\n    let el: any =\n      typeof selectorOrNode === 'string' ? this.doc.querySelector(selectorOrNode) : selectorOrNode;\n    if (!el) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ROOT_NODE_NOT_FOUND,\n        (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          `The selector \"${selectorOrNode}\" did not match any elements`,\n      );\n    }\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n    return el;\n  }\n\n  parentNode(node: any): any {\n    return node.parentNode;\n  }\n\n  nextSibling(node: any): any {\n    return node.nextSibling;\n  }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      name = namespace + ':' + name;\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n\n  addClass(el: any, name: string): void {\n    el.classList.add(name);\n  }\n\n  removeClass(el: any, name: string): void {\n    el.classList.remove(name);\n  }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n\n  removeStyle(el: any, style: string, flags: RendererStyleFlags2): void {\n    if (flags & RendererStyleFlags2.DashCase) {\n      // removeProperty has no effect when used on camelCased properties.\n      el.style.removeProperty(style);\n    } else {\n      el.style[style] = '';\n    }\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    if (el == null) {\n      return;\n    }\n\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      this.throwOnSyntheticProps &&\n      checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n\n  setValue(node: any, value: string): void {\n    node.nodeValue = value;\n  }\n\n  listen(\n    target: 'window' | 'document' | 'body' | any,\n    event: string,\n    callback: (event: any) => boolean,\n    options?: ListenerOptions,\n  ): () => void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) &&\n      this.throwOnSyntheticProps &&\n      checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      target = getDOM().getGlobalEventTarget(this.doc, target);\n      if (!target) {\n        throw new RuntimeError(\n          RuntimeErrorCode.UNSUPPORTED_EVENT_TARGET,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            `Unsupported event target ${target} for event ${event}`,\n        );\n      }\n    }\n\n    let wrappedCallback = this.decoratePreventDefault(callback);\n\n    if (this.tracingService?.wrapEventListener) {\n      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);\n    }\n\n    return this.eventManager.addEventListener(\n      target,\n      event,\n      wrappedCallback,\n      options,\n    ) as VoidFunction;\n  }\n\n  private decoratePreventDefault(eventHandler: Function): Function {\n    // `DebugNode.triggerEventHandler` needs to know if the listener was created with\n    // decoratePreventDefault or is a listener added outside the Angular context so it can handle\n    // the two differently. In the first case, the special '__ngUnwrap__' token is passed to the\n    // unwrap the listener (see below).\n    return (event: any) => {\n      // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function\n      // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The\n      // debug_node can inspect the listener toString contents for the existence of this special\n      // token. Because the token is a string literal, it is ensured to not be modified by compiled\n      // code.\n      if (event === '__ngUnwrap__') {\n        return eventHandler;\n      }\n\n      // Run the event handler inside the ngZone because event handlers are not patched\n      // by Zone on the server. This is required only for tests.\n      const allowDefaultBehavior =\n        typeof ngServerMode !== 'undefined' && ngServerMode\n          ? this.ngZone.runGuarded(() => eventHandler(event))\n          : eventHandler(event);\n      if (allowDefaultBehavior === false) {\n        event.preventDefault();\n      }\n\n      return undefined;\n    };\n  }\n}\n\nconst AT_CHARCODE = (() => '@'.charCodeAt(0))();\n\nfunction checkNoSyntheticProp(name: string, nameKind: string) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNEXPECTED_SYNTHETIC_PROPERTY,\n      `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Make sure \\`provideAnimationsAsync()\\`, \\`provideAnimations()\\` or \\`provideNoopAnimations()\\` call was added to a list of providers used to bootstrap an application.\n  - There is a corresponding animation configuration named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.dev/api/core/Component#animations).`,\n    );\n  }\n}\n\nfunction isTemplateNode(node: any): node is HTMLTemplateElement {\n  return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\n\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  private shadowRoot: ShadowRoot;\n\n  constructor(\n    eventManager: EventManager,\n    private hostEl: HTMLElement,\n    private component: RendererType2,\n    doc: Document,\n    ngZone: NgZone,\n    nonce: string | null,\n    platformIsServer: boolean,\n    tracingService: TracingService<TracingSnapshot> | null,\n    private sharedStylesHost: SharedStylesHost,\n    private styleScopeService: IsolatedStyleScopeService,\n  ) {\n    super(eventManager, doc, ngZone, platformIsServer, tracingService);\n\n    // Only create shadow root in browser environments\n    if (!platformIsServer) {\n      this.shadowRoot = (hostEl as HTMLElement).attachShadow({mode: 'open'});\n    } else {\n      // In SSR or environments without shadow DOM support, throw\n      throw new Error(\n        'IsolatedShadowRoot is not supported in SSR mode until declarative shadow DOM is supported.',\n      );\n    }\n\n    // Determine if this is isolated based on component encapsulation\n    const isIsolated = component.encapsulation === ViewEncapsulation.IsolatedShadowDom;\n\n    // Register shadow root with StyleScopeService for style targeting (only if service available and in browser)\n    if (this.styleScopeService) {\n      if (isIsolated) {\n        this.styleScopeService.registerIsolatedShadowRoot(this.shadowRoot);\n        this.sharedStylesHost.addShadowRoot(this.shadowRoot);\n      } else {\n        this.styleScopeService.registerStandardShadowRoot(this.shadowRoot);\n        this.sharedStylesHost.addHost(this.shadowRoot);\n      }\n    }\n\n    let styles = component.styles;\n    if (ngDevMode) {\n      // We only do this in development, as for production users should not add CSS sourcemaps to components.\n      const baseHref = getDOM().getBaseHref(doc) ?? '';\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n\n    if (isIsolated && !platformIsServer) {\n      // For IsolatedShadowDom, use SharedStylesHost with shadowRoot targeting\n      this.sharedStylesHost.addStyles(styles, component.getExternalStyles?.(), this.shadowRoot);\n    } else {\n      // For standard ShadowDom or SSR, use original approach\n      styles = shimStylesContent(component.id, styles);\n\n      for (const style of styles) {\n        const styleEl = doc.createElement('style');\n\n        if (nonce) {\n          styleEl.setAttribute('nonce', nonce);\n        }\n\n        styleEl.textContent = style;\n        this.shadowRoot.appendChild(styleEl);\n      }\n\n      // Apply any external component styles to the shadow root for the component's element.\n      // The ShadowDOM renderer uses an alternative execution path for component styles that\n      // does not use the SharedStylesHost that other encapsulation modes leverage. Much like\n      // the manual addition of embedded styles directly above, any external stylesheets\n      // must be manually added here to ensure ShadowDOM components are correctly styled.\n      // TODO: Consider reworking the DOM Renderers to consolidate style handling.\n      const styleUrls = component.getExternalStyles?.();\n      if (styleUrls) {\n        for (const styleUrl of styleUrls) {\n          const linkEl = createLinkElement(styleUrl, doc);\n          if (nonce) {\n            linkEl.setAttribute('nonce', nonce);\n          }\n          this.shadowRoot.appendChild(linkEl);\n        }\n      }\n    }\n  }\n\n  private nodeOrShadowRoot(node: HTMLElement): HTMLElement | ShadowRoot {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n\n  override appendChild(parent: HTMLElement, newChild: Node): void {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n\n  override insertBefore(parent: HTMLElement, newChild: Node, refChild: Node): void {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n\n  override removeChild(_parent: HTMLElement, oldChild: Node): void {\n    return super.removeChild(null, oldChild);\n  }\n\n  override parentNode(node: any): any {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n\n  override destroy() {\n    // Query the service to determine what type this shadow root is (only if service available and in browser)\n    if (!this.platformIsServer) {\n      if (this.styleScopeService.isIsolatedShadowRoot(this.shadowRoot)) {\n        this.styleScopeService.deregisterIsolatedShadowRoot(this.shadowRoot);\n        this.sharedStylesHost.removeShadowRoot(this.shadowRoot);\n      } else if (this.styleScopeService.isStandardShadowRoot(this.shadowRoot)) {\n        this.styleScopeService.deregisterStandardShadowRoot(this.shadowRoot);\n        this.sharedStylesHost.removeHost(this.shadowRoot);\n      }\n    }\n  }\n}\n\nclass NoneEncapsulationDomRenderer extends DefaultDomRenderer2 {\n  protected readonly styles: string[];\n  protected readonly styleUrls?: string[];\n\n  constructor(\n    eventManager: EventManager,\n    protected readonly sharedStylesHost: SharedStylesHost,\n    component: RendererType2,\n    private removeStylesOnCompDestroy: boolean,\n    doc: Document,\n    ngZone: NgZone,\n    platformIsServer: boolean,\n    tracingService: TracingService<TracingSnapshot> | null,\n    protected styleScopeService: IsolatedStyleScopeService,\n    compId?: string,\n  ) {\n    super(eventManager, doc, ngZone, platformIsServer, tracingService);\n    let styles = component.styles;\n    if (ngDevMode) {\n      // We only do this in development, as for production users should not add CSS sourcemaps to components.\n      const baseHref = getDOM().getBaseHref(doc) ?? '';\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n\n    this.styles = compId ? shimStylesContent(compId, styles) : styles;\n    this.styleUrls = component.getExternalStyles?.(compId);\n  }\n\n  applyStyles(element: HTMLElement): void {\n    // Check if we should target specific shadow roots (only if service and element available)\n    if (element && !this.platformIsServer) {\n      const targetShadowRoots = this.styleScopeService.determineStyleTargets(element);\n      if (targetShadowRoots.length > 0) {\n        for (const shadowRoot of targetShadowRoots) {\n          this.sharedStylesHost.addStyles(this.styles, this.styleUrls, shadowRoot);\n        }\n        return;\n      }\n    }\n\n    // Default behavior: apply to document head and all standard shadow hosts\n    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);\n  }\n\n  override destroy(): void {\n    if (!this.removeStylesOnCompDestroy) {\n      return;\n    }\n    if (allLeavingAnimations.size === 0) {\n      this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);\n    }\n  }\n}\n\nclass EmulatedEncapsulationDomRenderer2 extends NoneEncapsulationDomRenderer {\n  private contentAttr: string;\n  private hostAttr: string;\n\n  constructor(\n    eventManager: EventManager,\n    sharedStylesHost: SharedStylesHost,\n    component: RendererType2,\n    appId: string,\n    removeStylesOnCompDestroy: boolean,\n    doc: Document,\n    ngZone: NgZone,\n    platformIsServer: boolean,\n    tracingService: TracingService<TracingSnapshot> | null,\n    styleScopeService: IsolatedStyleScopeService,\n  ) {\n    const compId = appId + '-' + component.id;\n    super(\n      eventManager,\n      sharedStylesHost,\n      component,\n      removeStylesOnCompDestroy,\n      doc,\n      ngZone,\n      platformIsServer,\n      tracingService,\n      styleScopeService,\n      compId,\n    );\n    this.contentAttr = shimContentAttribute(compId);\n    this.hostAttr = shimHostAttribute(compId);\n  }\n\n  applyToHost(element: HTMLElement): void {\n    // Use inherited applyStyles method to handle shadow root targeting and fallback\n    this.applyStyles(element);\n    this.setAttribute(element, this.hostAttr, '');\n  }\n\n  override createElement(parent: any, name: string): Element {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\n"],"names":["addEventListener","element","eventName","handler","options","removeEventListener","target","callback","EVENT_MANAGER_PLUGINS","InjectionToken","ngDevMode","undefined","EventManager","_zone","_plugins","otherPlugins","slice","reverse","domEventPlugin","plugins","find","p","DomEventsPlugin","push","elements","remove","external","set","styleElement","href","usage","textContent","inline","nonce","inlineMap","Map","externalMap","doc","head","addUsage","value","usagesMap","creator","targetShadowRoot","record","shouldAddToHosts","styleRoot","standardShadowHosts","size","addElement","host","removeUsageFromTarget","usages","get","removeElements","ngOnDestroy","values","clear","hostNode","createStyleElement","style","headExternal","createLinkElement","url","delete","IsolatedStyleScopeService","standardShadowRoots","shadowRoot","isolatedShadowRoots","deregisterStandardShadowRoot","ShadowRoot","elementRoot","isRegisteredShadowRoot","result","e","findShadowRootViaLView","Set","visited","has","lView","add","HOST","hostElement","unwrapRNode","hostRNode","Element","shadowRoots","parentLView","PARENT","Array","isArray","checkIfShadowRootHost","getShadowRootsForContext","NAMESPACE_URIS","COMPONENT_REGEX","PROTOCOL_REGEXP","COMPONENT_VARIABLE","HOST_ATTR","CONTENT_ATTR","shimHostAttribute","componentShortId","replace","shimStylesContent","compId","styles","map","s","cssContent","SOURCEMAP_URL_REGEXP","_","sourceMapUrl","startsWith","pathname","resolvedSourceMapUrl","URL","absoluteBaseHrefUrl","platformId","ngZone","tracingService","styleScopeService","rendererByCompId","defaultRenderer","platformIsServer","constructor","eventManager","sharedStylesHost","appId","removeStylesOnCompDestroy","ngServerMode","DefaultDomRenderer2","createRenderer","type","encapsulation","ViewEncapsulation","Emulated","renderer","EmulatedEncapsulationDomRenderer2","ShadowDom","IsolatedShadowDom","ShadowDomRenderer","id","componentReplaced","componentId","ɵfac","i0","ɵɵngDeclareFactory","minVersion","version","ngImport","DomRendererFactory2","deps","token","i1","i2","APP_ID","REMOVE_STYLES_ON_COMPONENT_DESTROY","DOCUMENT","PLATFORM_ID","NgZone","CSP_NONCE","TracingService","optional","i3","ɵɵFactoryTarget","Injectable","decorators","ctorParameters","Document","Object","ɵTracingService","throwOnSyntheticProps","destroy","createElement","name","namespace","createComment","createText","createTextNode","appendChild","parent","newChild","isTemplateNode","content","insertBefore","refChild","targetParent","oldChild","selectRootElement","selectorOrNode","preserveContent","RuntimeError","el","setAttribute","namespaceUri","setAttributeNS","removeAttribute","removeClass","flags","RendererStyleFlags2","DashCase","Important","setProperty","removeStyle","removeProperty","checkNoSyntheticProp","node","nodeValue","getDOM","getGlobalEventTarget","event","decoratePreventDefault","wrappedCallback","wrapEventListener","eventHandler","allowDefaultBehavior","runGuarded","nameKind","tagName","hostEl","component","attachShadow","mode","isIsolated","registerIsolatedShadowRoot","registerStandardShadowRoot","addHost","baseHref","getBaseHref","addBaseHrefToCssSourceMap","addStyles","getExternalStyles"],"mappings":"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"}